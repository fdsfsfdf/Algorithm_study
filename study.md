# 알고리즘 공부
==========
이것이 코딩 테스트다 with 파이썬(저자- 나동빈 참고)

>## 1. Greedy Algorithm   
* 현재 상황에서 가장 좋은 것만 선택   
* Dijkstra, Floyd-Warsahall 같은 알고리즘도 그리디 알고리즘에 속함   
* 모든 상황에서 최적의 해를 보장하지는 않지만 맞는 케이스의 경우 효과적이고 직관적   
* 그리디 알고리즘으로 문제의 해답을 찾았을 경우 해답의 정당성 검토 필요  
* 대표문제: 거스름돈   
* 거스름돈의 경우, 가지고 있는 동전 중에서 큰 단위가 항상 작은 단위의 배수이므로 작은 단위의 동전들을 종합해 다른 해가 나올 수 없다. (400원 짜리도 있었다면, 500원이 400의 배수가 아니므로 안됨.)   
* 대부분의 그리디 알고리즘 문제에서는 "최소한의 아이디어를 떠올리고  정당한지 검토할 수 있어야 정답 도출가능"	

>## 2. 구현
* 구현 = '머리 속 알고리즘을 소스코드로 바꾸는 과정'
* 이 책에서는 완전탐색, 시뮬레이션 유형을 모두 구현으로 묶어서 다루고 있다.
* 완전탐색(Brute Forcing) = 모든 경우의 수를 다 계산하는 해결 방법
* 시뮬레이션 = 문제에서 제시한 알고리즘을 한 단계식 차례대로 직접 수행
* C++이나 java를 사용할 시에는 int형의 최대범위(약 21억) 등 고려해야할 사안이 많지만 python에서는 상대적으로 자료형의 표현 범위 제한에 대해 깊이 이해하지 않아도 된다.
* 다만 데이터 처리량이 많을 때는 메모리제한을 고려해야한다. 데이터의 개수가 1000개인 list의 메모리 사용량은 약 4kb, 10,000,000인 경우 약 40mb이다. 
* 사실 메모리 제한 보다 입출력 속도에 걸릴 경우가 많아 복잡한 최적화 까진 생각하지 않아도 된다. 
* 일반적으로 2020년 기준 1초에 2000만 번 연산 수행한다고 하면 시간면에서는 안정적이다. 
* 시간 제한 1초, 데이터 개수 100만 개인 문제라면 O(N log N )의 알고리즘을 이용해야 한다. N log N이 약 2천만 개이기 때문. 따라서 알고리즘 문제 풀 때는 시간 제한과 데이터의 개수를 확인 한 후 어느 정도 시간 복잡도의 알고리즘을 사용해야 풀 수 있을지 예측해야 함.

>## 3.DFS/BFS
* 탐색(search) = 원하는 데이터를 탐색하는 과정. 대표적으로 DFS, BFS 등이 있는데 기본 자료구조인 스택과 큐에 대한 이해가 필요
* 자료구조(Data Structure) = 데이터를 표현하고 관리하고 처리하기 위한 구조. 그중 스택과 큐는 Push, Pop을 핵심함수로 사용한다. 
* 스택(Stack) = First In Last Out. 엘리베이터, 박스 쌓기. 파이썬에서는 append()와 pop()을 이용하면 된다. 마지막에 넣고 마지막을 꺼내기 때문에.
* 큐(Queue) = First In First Out. 
* 재귀함수 = 자기 자신을 다시 호출 하는 함수. 종료 조건을 꼭 명시해야함. 
* Graph = node(노드)와 Edge(간선)로 표현됨. 프로그래밍에서 크게 2가지 방식으로 표현됨. Adjacency Matrix(인접 행렬): 2차원 배열로 그래프의 연결관계를 표현하는 방식, Adjacency List(인접 리스트): 리스트로 그래프의 연결 관계를 표현하는 방식
* 인접 행렬방식과 인접 리스트 방식의 장단점: 인접 리스트는 데이터 얻는 속도 느린 대신 메모리 효율적으로 사용. 
* DFS = 깊이 우선 탐색. 그래프에서 깊은 부분을 우선적으로 탐색하는 알고리즘. 스택을 이용.
1) 탐색 시작 노드를 스택에 삽입하고 방문 처리를 한다.        
2) 스택의 최상단 노드에 방문하지 않은 인접 노드가 있으면 그 인접 노드를 스택에 넣고 방문 처리를 한다. 방문하지 않은 인접 노드가 없으면 스택에서 최상단 노드를 꺼낸다.    
3) 2)의 과정을 더 이상 수행할 수 없을 때까지 반복한다.    
* BFS = 너비 우선 탐색. 가까운 노드부터 탐색하는 알고리즘. queue를 사용.
1) 탐색 시작 노드를 큐에 삽입하고 방문 처리를 한다.    
2) 큐에서 노드를 꺼내 해당 노드의 인접 노드 중에서 방문하지 않은 노드를 모두 큐에 삽입하고 방문 처리를 한다.     
3) 2)의 과정을 더 이상 수행할 수 없을 때까지 반복한다.    

>## 4.정렬
* 정렬 = 데이터를 특정한 기준에 따라서 순서대로 나열하는 것. 
* 선택 정렬 = 전체 데이터 중 가장 작은 데이터를 선택해 맨 앞에 있는 데이터와 바꾸고 그 다음 작은 데이터를 선택해 앞에서 두 번째 데이터와 바꾸는 과정 반복     
-->시간복잡도 계산: N + (N-1) + (N-2) .... = N(N+1)/2 = O(N^2)
* 삽입 정렬 = 특정한 데이터를 적절한 위치에 삽입하여 정렬. 데이터가 거의 정렬되어있을 시 효율적인 정렬법. 처음 데이터는 정렬이 되어있다고 생각하고, 두 번째 데이터는 그보다 크면 뒤에 놓고 작으면 앞에 놓는다.    
--> 시간복잡도: O(N^2), 대신 정렬이 거의 되어있는 경우, 퀵 정렬보다도 빠르다.    
* 퀵정렬 = 기준 데이터를 설정하고 기준보다 큰 데이터와 작은 데이터의 위치를 바꾼다. 피벗을 사용하는데 이는 교환을 위한 기준이다. 예를 들면         
    1) 리스트에서 첫 번째 데이터를 피벗으로 정한다.    
    2) 피벗 설정 후에는 왼쪽에서부터 피벗보다 큰 데이터를 찾고, 오른쪽에서부터 피벗보다 작은 데이터를 찾는다.     
    3) 큰 데이터와 작은 데이터의 위치를 서로 교환해준다. 이를 1)부터 반복한다.    
--> 시간복잡도: O(NlogN), 대신 대부분 정렬이 되어있는 경우 매우 느리게 동작해 O(N^2). 삽입 정렬과 정반대. 
* 계수정렬: 특정한 조건이 부합할 때만 사용할 수 있지만 매우 빠른 정렬 알고리즘. 데이터의 크기 범위가 제한되어 정수형태로 표현할수 있을때만 사용. 가장 큰 데이터와 가장 작은 데이터의 차이가 100만을 넘지 않을 때 효과적으로 사용할 수 있다. 그냥 정수 리스트가 있으면 새로운 룩업 테이블을 만들어 cnt를 올리고 순서대로 출력하는 것.    
--> 시간복잡도: O(N+K). 데이터 개수 + 최대값 크기 K. 다만 경우에 따라 공간복잡도가 매우 높아지므로 데이터 특성 파악이 어렵다면 퀵 정렬 이용하는 것이 유리하다.
* 파이썬에서는 sorted() 함수를 제공하는데, 이는 병합 정렬 기반이다. 일반적으로 퀵 정렬보다는 느리지만 최악의 경우에도 시간 복잡도 O(NlogN)을 보장한다.
