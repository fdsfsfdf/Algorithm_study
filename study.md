# 알고리즘 공부
==========
이것이 코딩 테스트다 with 파이썬(저자- 나동빈 참고)

>## 1. Greedy Algorithm   
* 현재 상황에서 가장 좋은 것만 선택   
* Dijkstra, Floyd-Warsahall 같은 알고리즘도 그리디 알고리즘에 속함   
* 모든 상황에서 최적의 해를 보장하지는 않지만 맞는 케이스의 경우 효과적이고 직관적   
* 그리디 알고리즘으로 문제의 해답을 찾았을 경우 해답의 정당성 검토 필요  
* 대표문제: 거스름돈   
* 거스름돈의 경우, 가지고 있는 동전 중에서 큰 단위가 항상 작은 단위의 배수이므로 작은 단위의 동전들을 종합해 다른 해가 나올 수 없다. (400원 짜리도 있었다면, 500원이 400의 배수가 아니므로 안됨.)   
* 대부분의 그리디 알고리즘 문제에서는 "최소한의 아이디어를 떠올리고  정당한지 검토할 수 있어야 정답 도출가능"	

>## 2. 구현
* 구현 = '머리 속 알고리즘을 소스코드로 바꾸는 과정'
* 이 책에서는 완전탐색, 시뮬레이션 유형을 모두 구현으로 묶어서 다루고 있다.
* 완전탐색(Brute Forcing) = 모든 경우의 수를 다 계산하는 해결 방법
* 시뮬레이션 = 문제에서 제시한 알고리즘을 한 단계식 차례대로 직접 수행
* C++이나 java를 사용할 시에는 int형의 최대범위(약 21억) 등 고려해야할 사안이 많지만 python에서는 상대적으로 자료형의 표현 범위 제한에 대해 깊이 이해하지 않아도 된다.
* 다만 데이터 처리량이 많을 때는 메모리제한을 고려해야한다. 데이터의 개수가 1000개인 list의 메모리 사용량은 약 4kb, 10,000,000인 경우 약 40mb이다. 
* 사실 메모리 제한 보다 입출력 속도에 걸릴 경우가 많아 복잡한 최적화 까진 생각하지 않아도 된다. 
* 일반적으로 2020년 기준 1초에 2000만 번 연산 수행한다고 하면 시간면에서는 안정적이다. 
* 시간 제한 1초, 데이터 개수 100만 개인 문제라면 O(N log N )의 알고리즘을 이용해야 한다. N log N이 약 2천만 개이기 때문. 따라서 알고리즘 문제 풀 때는 시간 제한과 데이터의 개수를 확인 한 후 어느 정도 시간 복잡도의 알고리즘을 사용해야 풀 수 있을지 예측해야 함.
